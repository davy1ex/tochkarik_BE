import React, {useEffect, useState} from "react";
import MapComponent from '../../components/Map/MapComponent';
import RadiusSlider from '../../components/Map/Slider/RadiusSlider';
import ManualLocationInput from '../../components/Map/ManualLocation/ManualLocationInput';
import ErrorMessage from '../../components/Map/ErrorMessage/ErrorMessage';
import GeneratedPoint from '../../components/Map/GeneratedPoint/GeneratedPoint'
import BigButton from "../../components/Buttons/BigButton";

import {axiosPublicInstance} from "../../services/authService";

import useLocationHandler from '../../components/Map/hooks/useLocationHandler';

import './HomePage.css';
import '../../components/Map/Map.css'


/**
 * Renders the HomePage component which displays a map with a radius slider and a button to generate a new point.
 *
 * @return {ReactElement} The rendered HomePage component.
 */
const HomePage: React.FC = () => {
    const [locationType, setLocationType] = useState<string | null>(null);
    const [position, setPosition] = useState<[number, number] | null>([55.54885516305257, 37.54244046838186]);
    const [radius, setRadius] = useState<number>(500);
    const [markerPosition, setMarkerPosition] = useState<[number, number] | null>(null);
    const [street, setStreet] = useState<string>('');
    const [timeOfGenerate, setTimeOfGenerate] = useState<string>('');
    const [telemetryId, setTelemetryId] = useState<string>(0);

    const [showControls, setShowControls] = useState<boolean>(true);
    const [error, setError] = useState<string>('');

    const { generateRandomCoordinates, getStreetName, getFormattedTime, updatePositionWithNearbyPlace } = useLocationHandler();

    const [pointId, setPointId] = useState<number | null>(null);

    useEffect(() => {
        navigator.geolocation.getCurrentPosition(async (position) => {
            const { latitude, longitude } = position.coords;
            setPosition([latitude, longitude]);
        });
    }, []);

    /**
     * Updates the radius state based on the value of the HTML input element.
     *
     * @param {React.ChangeEvent<HTMLInputElement>} event - The event object containing the target input element.
     * @return {void} This function does not return anything.
     */
    const handleRadiusChange = (event: React.ChangeEvent<HTMLInputElement>) => {
        setRadius(Number(event.target.value));
    };

    /**
     * Handles the generation of a new point based on the current location and add telemetry.
     *
     * This function sends a GET request to retrieve the generation rules from the server.
     * It then updates the location type based on the retrieved data.
     *
     * The function calls the `updatePositionWithNearbyPlace` function to update the position and determine if the new position is generated by a rule.
     * If the new position is not generated by a rule, the final position is set to the current position.
     * Otherwise, the radius is set to 100.
     *
     * The function generates new random coordinates based on the final position and radius.
     * It then sets the marker position to the new coordinates.
     *
     * The function retrieves the street name using the `getStreetName` function.
     * It sets the street name and time of generate.
     *
     * The function sets the controls to be hidden.
     *
     * The function sends a POST request to create a new point telemetry with the generated data.
     * It sets the telemetry ID and logs the response data.
     *
     * @return {Promise<void>} A Promise that resolves when the generation process is complete.
     */
    const handleGenerate = async () => {
        await axiosPublicInstance.get('/generation_rules')
            .then(response => {
                setLocationType(response.data.data[0].rules.type[0]);

            })

        const { newPosition, generatedByRule } = await updatePositionWithNearbyPlace(position!, radius, locationType, setPosition);
        let finalPosition = newPosition
        let radiusForGenerate = radius;
        if (!newPosition) {
            finalPosition = position;
        }
        else {
            radiusForGenerate = 100;
        }

        const [newLatitude, newLongitude] = await generateRandomCoordinates(finalPosition!, radiusForGenerate);
        setMarkerPosition([newLatitude, newLongitude]);

        const streetName = await getStreetName(newLatitude, newLongitude);
        setStreet(streetName);

        const formattedTime = getFormattedTime(newLatitude, newLongitude);
        setTimeOfGenerate(formattedTime);

        setShowControls(false);

        axiosPublicInstance.post('/point_telemetry', {
            name: 'Generated Point',
            coordinates: position,
            timeOfGenerate: formattedTime,
            description: street,
            isVisited: false,
            generatedByRule: generatedByRule
        }).then(response => {
            setTelemetryId(response.data.data.id);
            console.log("RETURNED POINTTELEMETRY: ", response.data.data)
        });
    };

    /**
     * Handles the creation of a report by sending a PUT request to update the visited status of a point telemetry.
     *
     * @return {void} This function does not return anything.
     */
    const handleCreateReport = () => {
        console.log("TRY PUT: ", telemetryId)

        axiosPublicInstance.put(`/point_telemetry/${telemetryId}`, {
            visited: true
        });
    }

    /**
     * Resets the marker position, shows controls, and clears street, time of generate, and point id.
     *
     * @return {void} This function does not return anything.
     */
    const handleCancel = () => {
        setMarkerPosition(null);
        setShowControls(true);
        setStreet('');
        setTimeOfGenerate('');
        setPointId(null);
    };

    return (
        <div className="home-container">
            {position ? (
                <>
                    <MapComponent
                        coordinates={markerPosition}
                        showRadius={true}
                        radius={radius}
                        centerPosition={position}
                    />
                    {showControls ? (
                        <div className="controls-container">
                            <div className={"controls-container-wrapper"}>
                                {street}
                                <RadiusSlider radius={radius} handleRadiusChange={handleRadiusChange}/>
                                <BigButton onClick={handleGenerate}>Generate</BigButton>
                                <ManualLocationInput setPosition={setPosition} setError={setError}/>
                                {error && <ErrorMessage message={error}/>}
                            </div>
                        </div>
                    ) : (
                        <GeneratedPoint
                            pointId={pointId}
                            onSave={(id: number | null) => setPointId(id)}
                            street={street}
                            pointTitle="Point Generated"
                            isNew={true}
                            hasReport={false}  // Change this based on your logic
                            onCancel={handleCancel}
                            onCreateReport={(pointId: number) => handleCreateReport(pointId)}
                            onEditReport={}
                            coordinates={markerPosition}
                            timeOfGenerate={timeOfGenerate}
                        />
                    )}
                </>
            ) : (
                <>WAIT</>
            )}
            {error && <p className="error-message">{error}</p>}
        </div>
    );
};

export default HomePage;
